#+title: Nand2Tetris : Building a Modern Computer From First Principles - Part 1 : Hardware

* Motivation

I found it satisfying to implement a mini-programming language in Racket as part of the [[https://www.coursera.org/learn/programming-languages-part-b][Programming Languages]] course. This motivated me to seek to understand computing at its most fundamental level. Nand2Tetris offers a practical learning experience that puts together different aspects of Computer Science. It is a hands-on journey from primitive gates to a fully functioning computer capable of running Tetris.

In Part 1 we start from a primitive =Nand gate= and end with a working computer capable of executing =Hack= assembly instructions.

* Applied Skills and Preparation

** Mathematical Foundations

- [X] Boolean logic and circuit design
  - Converting between =Truth Tables= and =Boolean Expressions=
  - Simplifying =Boolean Expressions= using Logical Equivalences
  - Implementing optimized circuits from logical specifications
  - *Sources:*
    - Susanna Epp's *Discrete Mathematics with Applications* (5th Ed)

** Programming Languages & Systems

- [X] Programming languages and systems concepts
  - Type systems and static analysis for program correctness
  - Functional programming with =closures= and immutable data patterns
  - =Test-Driven Development= and comprehensive =unit testing= methodologies
  - Memory management concepts (=stack= vs =heap=)
  - Systems programming with =ownership=, =borrowing=, and zero-cost abstractions (Rust)
  - Modular program design and abstraction boundaries
  - =Regular expressions= and pattern matching for text processing
  - *Sources:*
    - CS50: Introduction to Computer Science (Harvard) - [[https://cs50.harvard.edu/certificates/98a971a5-2c6f-4fb7-aa60-4286fb823955][Certificate]]
    - University of Washington's Programming Languages:
      - [[https://www.coursera.org/learn/programming-languages][Part A]]
      - [[https://www.coursera.org/learn/programming-languages-part-b][Part B]]
      - [[https://www.coursera.org/learn/programming-languages-part-c][Part C]]
    - Mastering Regular Expressions by Jeffrey E. F. Friedl
    - The Rust Programming Language book

* Introduction and roadmap

** The Hello World Iceberg

The classic Hello World program is deceptively simple. But running it requires multiple levels of abstractions and interfaces: First of all, the code is just text that the computer doesn't understand. It needs to be parsed, its semantics determined and then we translate it to the low machine language of the target computer. The result will be machine language instructions. These instructions need to be realized by some /hardware architecture/. This architecture is in turn implemented using /elementary logic gates/. All these gates can be built from primitive gates like =Nand=.

** Which Computer?

Since we need a specific /hardware architecture/ to run any program, the question remains: which hardware architecture to choose? One choice is to build a widely-used computer architecture with an existing high-level language. But this would make the project subject to the changing trends of architectures and languages. This led to the decision to create the /Hack/ computer architecture and the =Jack= high-level language. This also has the benefit of simplicity, we get to learn the theoretical concepts and the concrete implementation that are common in even the industrial-scale architecture design, without being bogged down by the idiosyncracies of lard-scale complex design.

** Roadmap

The Nand to Tetris journey contains twelve hardware and software projects, six of which pertain to the hardware part:

- Chapter 1: Starting from /Nand/ and building elementary logic gates
- Chapter 2: Constructing an /Arithmetic Logic Unit/
- Chapter 3: Constructing memory devices
- Chapter 4: Introducing low-level machine language
- Chapter 5: Building the /CPU/ and /RAM/
- Chapter 6: Building an /assembler/

* Project Implementation

** Chapter 1: Boolean Logic

*** Introduction and Roadmap

Every digital device is built using elementary /logic gates/. Our starting point in this chapter is to start from /Nand/ and build:

- Basic gates: Not, And, Or, and Xor
- Multiplexer and Demultiplexer
- 16-bit versions: Not16, And16, and so on.

*** Core Concepts

- One subset of logical operators can be used to express /any/ boolean function
- ={And, Or, Not}= is one such subset
- /And/ , /Or/ and /Not/ can in turn be implemented using /Nand/ making it our /universal gate/
- Given a =truth table= we can construct the corresponding =boolean expression= and simplify it and then implement it using logical gates
- We use HDL (Hardware Description Language) to create software representation of the chips logic
- HDL allows us to plan, debug, test and optimize our chips before anything is committed to silicon

*** Component Specification and Implementation

**** Nand

The starting point of our computer architecture is the /Nand/ gate which realizes the following Boolean function:

| a | b | Nand(a,b) |
|---+---+-----------|
| 0 | 0 |         1 |
| 0 | 1 |         1 |
| 1 | 0 |         1 |
| 1 | 1 |         0 |

We can also use API style notation to describe the same function:

#+begin_src

Chip name: Nand
Input: a, b
Output: out
Function: if ((a==1) and (b==1)) then out = 0, else out = 1

#+end_src

The API description is more concise and it specifies the chip's name, its inputs and outputs and the function that it performs. It will be used in the rest of this documentation.

**** Not

Also called an /inverter/. It realizes the following API:

#+begin_src

Chip name: Not
Input: in
Output: out
Function: if (in==0) then out=1, else out=0

#+end_src

Given the rules of Boolean algebra: =~ a = ~ (a ^ t) => Nand(a, True)=

**** And

Realizes the following API:

#+begin_src

Chip name: And
Input: a, b
Output: out
Function: if ((a==1) and (b==1)) then out=1, else out=0

#+end_src

=a ^ b = ~ (~ ( a ^ b )) => Not(Nand(a, b))=

**** Or

The /Or/ gate realizes the following function:

#+begin_src

Chip name: Or
Input: a, b
Output: out
Function: if ((a==1) or (b==1)) then out=1, else out=0

#+end_src

According to De Morgan's Laws =a ∨ b = ~ ( ~ a ∧ ~ b)= which can be represented as =Not(And(Not(a), Not(b)))=.

**** Xor

The /Xor/ gate realizes the following function:

#+begin_src

Chip name: Xor
Input: a, b
Output: out
Function: if (a != b) then out=1, else out=0

#+end_src

Xor can be represented in Boolean notation as: =(a V b) ^ ~ (a ^ b)= which can be represented as =And(Or(a,b), Not(And(a,b)))=

**** Multiplexer

A /multiplexer/ is a three-input gate. Two input bits /a/ and /b/ are interpreted as /data bits/ and a third input bit named /sel/ is a interpreted as a /selection bit/. It routes one of the /data bits/ to the /output/ based on the /selection bit/.

Here is the API:

#+begin_src

Chip name: Mux
Input: a, b, sel
Output: out
Function: if (sel==0) then out=a, else out=b

#+end_src

This logic can be noted as: =(~ sel ^ a) V (sel ^ b)=

**** Demultiplexer

It performs the opposite function of the /multiplexer/. It takes a single input and routes it to one of two possible outputs. It has this API:

#+begin_src

Chip name: DMux
Input: in, sel
Output: a, b
Function: if (sel==0) then {a,b} = {in,0}, else {a,b} = {0,in}

#+end_src

We can see that /a/ will only be true if /sel/ is /false/ and /in/ is /true/, therefore : =a = ~self^in=. /b/ will only be true when /sel/ is /true and /in/ is true, therefore =b = sel^in=.

**** Multi-bit Versions

It's a simple matter of arranging the one-bit gates into n-bit arrays that operate on each bit separately. In this case we implement 16-bit version of the gates.

***** Mistakes and Lessons Learned

My first attempt was to copy the /implementation/ of each gate 16 times, which is unnecessarily complex. It is much more concise to use the gate already implemented directly. This enforced the distinction between =specification= and =implementation= that the book emphasizes. As we move to more complex chips, we can treat the previous chips as /black boxes/ and not worry about the details of how they are implemented.

**** Multi-way variants

Logic gates that operate on one or two inputs can be generalized to gates that operate on multiple inputs.
The way to implement them is to try to express the logic of the multiple inputs a /fork/ of the logic of the gates already implemented. Since the logic is the same, we won't go into details for each chip.

***** Or8Way

/Or8Way/ the following API:

#+begin_src

Chip name: Or8Way
Input: in[8]
Output: out
Function: out = Or(in[0], in[1], ..., in[7])

#+end_src

This can be implemented by using /Or/ for two inputs and then forking the output and using it as input for the next /Or/.

The logic looks like this:

#+begin_src

    Or(a=in[0] , b=in[1] , out=out1);
    Or(a=out1 , b=in[2] , out=out2);
    Or(a=out2 , b=in[3] , out=out3);
  ...

#+end_src

*Note:* The general logic is to express the Multi-way variant using a combination of the two-inputs variant.

***** Multi-way/Multi-bit multiplexer

/Mux4Way16/ has the following API:

#+begin_src

Chip name: Mux4Way16
Input: a[16], b[16], c[16], d[16], sel[2]
Output: out[16]
Function: if (sel==00,01,10,11) then out=(a,b,c,d)

#+end_src

This can be implemented using this : =Mux16(Mux16(a,b),Mux16(c,d))=

/Mux8Way16/ is implemented the same way.

***** Multi-way demultiplexer

/DMux4Way/ has the following API:

#+begin_src

Chip name: DMux4Way
Input: in, sel[2]
Output: a, b, c, d
Function: if (sel==00) then {a,b,c,d} = {in,0,0,0} else
if (sel==01) then {a,b,c,d} = {0,in,0,0} else
if (sel==10) then {a,b,c,d} = {0,0,in,0} else
if (sel==11) then {a,b,c,d} = {0,0,0,in}

#+end_src

To implement this, we first use a /DMux/ with =sel[1]= and then route the output to two other /DMux/ gates.

/DMux8Way/ can be implemented in the same way.

***** Mistakes and Lessons Learned

In programming languages =Array[0]= will be the index of the left-most element of the array. But in /HDL/ =sel[0]= is the *least significant bit* so it's the rightmost bit in the binary representation.
This led me to some confusion and headaches when implementing the /DMux/ multi-way variants.

** Chapter 2: Boolean Arithmetic
*** Introduction and Roadmap

Every general-purpose computer is required to perform arithmetic operations on signed integers. We'll start by developing logic gates that carry on /addition/ and /sign conversion/. The subsequent operations can be built using these two. In this chapter we will build:

- Half-adder: designed to add two bits
- Full-adder: designed to add three bits
- Adder: designed to add two n-bit numbers
- Incrementer: adds 1 to a given number
- The Arithmetic Logic Unit (ALU): Computes a set of arithmetic operations

*** Core Concepts

- Inside computers, everything is represented using binary code
- A pair of binary numbers can be added bitwise from right to left, while keeping track of the carry bit
- Signed binary numbers can represented using the /two's complement/ method.

  *Note:* For more information about the /two's complement/ method check: Susanna Epp's *Discrete Mathematics with Applications* (5th Ed) - Section 2.5 : /Application: Number Systems and Circuits for Addition/

*** Component Specification and Implementation

**** Half-adder

The half-adder computes the sum of two 1-bit inputs, producing a *sum* and a *carry*. It has the following API snf truth table:

#+begin_src

Chip name: HalfAdder
Input: a, b
Output: sum, carry
Function: sum = LSB of a + b, carry = MSB of a + b

#+end_src

| a | b | sum | carry |
|---|---|-----|-------|
| 0 | 0 |  0  |   0   |
| 0 | 1 |  1  |   0   |
| 1 | 0 |  1  |   0   |
| 1 | 1 |  0  |   1   |

From the truth table we can see that the sum is logically equivalent to a /Xor/ gate, and the carry is logically equivalent to an /And/ gate.

**** Full-adder

The /full-adder/ computes the sum of three 1-bit inputs, producing a sum and a carry. It has the following truth table:

| a | b | c | sum | carry |
|---|---|---|-----|-------|
| 0 | 0 | 0 |  0  |   0   |
| 0 | 0 | 1 |  1  |   0   |
| 0 | 1 | 0 |  1  |   0   |
| 0 | 1 | 1 |  0  |   1   |
| 1 | 0 | 0 |  1  |   0   |
| 1 | 0 | 1 |  0  |   1   |
| 1 | 1 | 0 |  0  |   1   |
| 1 | 1 | 1 |  1  |   1   |

The /full-adder/ can be implemented with two /half-adders/ and an /Or/ gate.

*Note:* For more information about the method of adding three bits see *Discrete Mathematics with Applications* (5th Ed) - Section 2.5 : /Application: Number Systems and Circuits for Addition/ - Page 97.

**** Adder

Integers are represented using a fixed word size like 8, 16, 32, or 64 bits. The addition of these n-bit numbers is realized using the /adder/ chip. It has the following API:

#+begin_src

Chip name: Add16
Input: a[16], b[16]
Output: out[16]
Function: Adds two 16-bit numbers, the overflow bit is ignored.

#+end_src

The Adder16 proceeds bitwise, from right to left. In step 0 the least significant bits are added and the carry is fed to the next addition. The last overflow carry bit is ignored. This can be implemented with a half-adder for the first addition and full-adders for the rest.

**** Incrementer

An /Incrementer/ is a chip that adds 1 to a given number. It has the following API:

#+begin_src

Chip name: Inc16
Input: in[16]
Output: out[16]
Function: out = in + 1

#+end_src

This can be realized using the previously designed /Add16/ chip. This can be done simply like this:

#+begin_src

CHIP Inc16 {
    IN in[16];
    OUT out[16];

    PARTS:
    Add16(a=in, b[0]=true , b[1..15]=false, out=out);
}

#+end_src

***** Mistakes and Lessons Learned

I first implemented the /Inc16/ chip using 16 /half-adders/, which was overly complex. The lesson is to use an already implemented chip whenever possible and treat it as a black-box abstraction for implementing future chips.

**** The Arithmetic Logic Unit

Using the generic chips built until now, we now turn to constructing the /ALU/. This chip's design is specific to our /Nand to Tetris/ computer. The /ALU/ will be the centerpiece of the /CPU/ chip we'll construct in a later chapter. It has the following API:

#+begin_src

Chip name: ALU
Input: x[16], y[16],  // 16-bit inputs
       zx,             // zero the x input
       nx,             // negate the x input
       zy,             // zero the y input
       ny,             // negate the y input
       f,              // if f==1 then out=x+y else out=x&y
       no              // negate the output
Output: out[16],       // 16-bit output
        zr,            // out == 0
        ng             // out < 0
Function:
  if zx then x = 0      // zero the x input
  if nx then x = !x     // negate the x input
  if zy then y = 0      // zero the y input
  if ny then y = !y     // negate the y input
  if f==1 then out = x + y // integer addition
         else out = x & y  // bitwise and
  if no then out = !out // negate the output
  zr = (out == 0)       // set if output is zero
  ng = (out < 0)        // set if output is negative

#+end_src

Given two 16-bit inputs /x/ and /y/ and six /control bits/, the /ALU/ computes a set of eighteen arithmetic and logical operations as seen in the tables below:

**ALU Control Bits:**

| Control bit | Function                              |
|-------------+---------------------------------------|
| zx          | Zero the x input                      |
| nx          | Negate the x input                    |
| zy          | Zero the y input                      |
| ny          | Negate the y input                    |
| f           | Function select: 1 for add, 0 for AND |
| no          | Negate the output                     |

**ALU Operations:**

| zx | nx | zy | ny | f | no | out |
|----+----+----+----+---+----+-----|
|  1 |  0 |  1 |  0 | 1 |  0 | 0   |
|  1 |  1 |  1 |  1 | 1 |  1 | 1   |
|  1 |  1 |  1 |  0 | 1 |  0 | -1  |
|  0 |  0 |  1 |  1 | 0 |  0 | x   |
|  1 |  1 |  0 |  0 | 0 |  0 | y   |
|  0 |  0 |  1 |  1 | 0 |  1 | !x  |
|  1 |  1 |  0 |  0 | 0 |  1 | !y  |
|  0 |  0 |  1 |  1 | 1 |  1 | -x  |
|  1 |  1 |  0 |  0 | 1 |  1 | -y  |
|  0 |  1 |  1 |  1 | 1 |  1 | x+1 |
|  1 |  1 |  0 |  1 | 1 |  1 | y+1 |
|  0 |  0 |  1 |  1 | 1 |  0 | x-1 |
|  1 |  1 |  0 |  0 | 1 |  0 | y-1 |
|  0 |  0 |  0 |  0 | 1 |  0 | x+y |
|  0 |  1 |  0 |  0 | 1 |  1 | x-y |
|  0 |  0 |  0 |  1 | 1 |  1 | y-x |
|  0 |  0 |  0 |  0 | 0 |  0 | x&y |
|  0 |  1 |  0 |  1 | 0 |  1 | x\vert{}y |

The operations are performed in order. For example if we want to compute the binary operation /27 - 1/ we proceed as follows:

- We feed the 16-bit binary code for 27 to the x input
- We set the /control bits/ to =001110=

let's walk through the operations to demonstrate that /x - 1/ is indeed computed:

- =zx = 0= and =nx = 0= => do nothing to /x/
- =zy = 1= => zero the /y/ input (y = 0)
- =ny = 1= => negate the /y/ input (y = -1)
- =f = 1= => perform x + y
- =no = 0= => don't negate the output

So at the end this ends up computing x + (-1).

*Implementation:*

We use /Mux16/ and /Not16/ for zeroing and negating outputs. In case of /x/ we have:

#+begin_src

    Mux16(a=x , b=false , sel=zx , out=xZeroed );
    Not16(in=xZeroed , out=xNegated );
    Mux16(a=xZeroed , b=xNegated , sel=nx , out=xResult );

#+end_src

We use /Add16/ and /And16/ to compute f and /Mux16/ for selection and then we use /Not16/ to postprocess the output.

#+begin_src

    Add16(a =xResult , b =yResult , out =addXY );
    And16(a=xResult , b=yResult , out=andXY );
    Mux16(a=andXY , b=addXY , sel=f , out=preOut );

    // postprocess output
    Not16(in=preOut , out=invertedOut );

#+end_src

All that's left now is outputting /ng/ and /zr/ bits. /ng/ is the /MSB/ of the whole output, and /zr/ can be calculated using a multi-way /Or/ gate. Since we only have an /Or8Way/ gate, we split the 16-bit output into two 8-bit parts, and use /Or8Way/ on each part.

#+begin_src

    Mux16(a=preOut , b=invertedOut , sel=no ,out=out, out[15] = ng, out[0..7]=lowerout, out[8..15]=upperout);

    // compute zr
    Or8Way(in=lowerout , out=lowerOr );
    Or8Way(in=upperout , out=upperOr );
    Or(a=lowerOr , b=upperOr , out=fullOr );
    Not(in=fullOr , out=zr );

#+end_src

** Chapter 3: Memory

*** Introduction and Roadmap
Every computer system needs to /store values over time/. The gates we implemented in previous chapters do not account for time and are referred to as =combinational chips=. In this chapter we will build a series of memory devices. These chips have the notion of a =clock cycle= and are referred to as =sequential chips=. They depend not only on the combination of their /inputs/ at a given time, but also on the /inputs/ and /outputs/ processed /previously/.

We will build:
- *Bit:* A single bit register
- *Register:* A 16-bit register chip
- *RAM:* A series of RAM devices with increasing number of registers
- *Counter:* A memory device that increments its value in every time unit


*** Core Concepts


- In /sequential logic/ we need access to the /current/ inputs and the /previous/ inputs and outputs
- This notion of /current/ and /previous/ imply a notion of time and the question of how to model it
- Time is modeled using a /clock/ that generates an ongoing train of binary signals referred to as /tick/ and /tock/
- The time between the beginning of a /tick/ and the end of a /tock/ is called a /cycle/
- Our model of time will be discrete. We ignore continuous change and care about the state of the world only during successive cycles
- The discrete model of time helps in ignoring the randomness of communication and synchronizing the operation of multiple chips.
- These cycles are achieved with the help of the *clock* and lower level Data-flip flop (DFF) chip.
- The duration of the clock cycle should be slightly longer than the most time consuming operation.
- The clock signal, realized using a binary signal, is broadcasted to every memory chip.

*** Component Specification and Implementation

**** Data Flip-Flop (DFF)

The /DFF/ is the most elementary sequential chip. It implements the simple time dependent behavior: =out(t) = in(t-1)=

This time dependency is realized by feeding the /master clock/ input directly to all /DFF/ gates. These gates will emit the input fed to them at the next clock cycle. In /Nand to Tetris/ we treat the /DFFs/ as elementary builtin low-level parts embedded deep within other memory devices.

**** Bit

/Bit/ is a single-bit register with the following API:

#+begin_src

Chip name: Bit
Input: in, load
Output: out
Function: If load(t) then out(t+1)=in(t) else out(t+1)=out(t)

#+end_src

The chip can store a single bit of information - 0 or 1 - over time. The /load/ input enables the register for writes. As long as the /load/ bit is not asserted the register is /latched/, maintaining its current state.

This behavior can be implemented using a /DFF/ and a /Multiplexer/. The /load/ bit is fed directly to the /sel/ bit of the /Mux/. The output of the /DFF/ and the current input are fed directly to the /Mux/.

#+begin_src
    Mux(a=currentVal, b=in, sel=load, out=muxOut );
    DFF(in=muxOut, out=currentVal, out=out );
#+end_src
