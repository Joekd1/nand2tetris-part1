#+title: Nand2Tetris : Building a Modern Computer From First Principles - Part 1 : Hardware

* Motivation

I found it satisfying to implement a mini-programming language in Racket as part of the [[https://www.coursera.org/learn/programming-languages-part-b][Programming Languages]] course. This motivated me to seek to understand computing at its most fundamental level. Nand2Tetris offers a practical learning experience that puts together different aspects of Computer Science. It is a hands-on journey from primitive gates to a fully functioning computer capable of running Tetris.

In Part 1 we start from a primitive =Nand gate= and end with a working computer capable of executing =Hack= assembly instructions.

* Applied Skills and Preparation

** Mathematical Foundations

- [X] Boolean logic and circuit design
  - Converting between =Truth Tables= and =Boolean Expressions=
  - Simplifying =Boolean Expressions= using Logical Equivalences
  - Implementing optimized circuits from logical specifications
  - *Sources:*
    - Susanna Epp's *Discrete Mathematics with Applications* (5th Ed)

** Programming Languages & Systems

- [X] Programming languages and systems concepts
  - Type systems and static analysis for program correctness
  - Functional programming with =closures= and immutable data patterns
  - =Test-Driven Development= and comprehensive =unit testing= methodologies
  - Memory management concepts (=stack= vs =heap=)
  - Systems programming with =ownership=, =borrowing=, and zero-cost abstractions (Rust)
  - Modular program design and abstraction boundaries
  - =Regular expressions= and pattern matching for text processing
  - *Sources:*
    - CS50: Introduction to Computer Science (Harvard) - [[https://cs50.harvard.edu/certificates/98a971a5-2c6f-4fb7-aa60-4286fb823955][Certificate]]
    - University of Washington's Programming Languages:
      - [[https://www.coursera.org/learn/programming-languages][Part A]]
      - [[https://www.coursera.org/learn/programming-languages-part-b][Part B]]
      - [[https://www.coursera.org/learn/programming-languages-part-c][Part C]]
    - Mastering Regular Expressions by Jeffrey E. F. Friedl
    - The Rust Programming Language book

* Introduction and roadmap

** The Hello World Iceberg

The classic Hello World program is deceptively simple. But running it requires multiple levels of abstractions and interfaces: First of all, the code is just text that the computer doesn't understand. It needs to be parsed, its semantics determined and then we translate it to the low machine language of the target computer. The result will be machine language instructions. These instructions need to be realized by some /hardware architecture/. This architecture is in turn implemented using /elementary logic gates/. All these gates can be built from primitive gates like =Nand=.

** Which Computer?

Since we need a specific /hardware architecture/ to run any program, the question remains: which hardware architecture to choose? One choice is to build a widely-used computer architecture with an existing high-level language. But this would make the project subject to the changing trends of architectures and languages. This led to the decision to create the /Hack/ computer architecture and the =Jack= high-level language. This also has the benefit of simplicity, we get to learn the theoretical concepts and the concrete implementation that are common in even the industrial-scale architecture design, without being bogged down by the idiosyncracies of lard-scale complex design.

** Roadmap

The Nand to Tetris journey contains twelve hardware and software projects, six of which pertain to the hardware part:

- Chapter 1: Starting from /Nand/ and building elementary logic gates
- Chapter 2: Constructing an /Arithmetic Logic Unit/
- Chapter 3: Constructing memory devices
- Chapter 4: Introducing low-level machine language
- Chapter 5: Building the /CPU/ and /RAM/
- Chapter 6: Building an /assembler/

* Project Implementation

** Chapter 1: Boolean Logic

*** Introduction and Roadmap

Every digital device is built using elementary /logic gates/. Our starting point in this chapter is to start from /Nand/ and build:

- Basic gates: Not, And, Or, and Xor
- Multiplexer and Demultiplexer
- 16-bit versions: Not16, And16, and so on.

*** Core Concepts

- One subset of logical operators can be used to express /any/ boolean function
- ={And, Or, Not}= is one such subset
- /And/ , /Or/ and /Not/ can in turn be implemented using /Nand/ making it our /universal gate/
- Given a =truth table= we can construct the corresponding =boolean expression= and simplify it and then implement it using logical gates
- We use HDL (Hardware Description Language) to create software representation of the chips logic
- HDL allows us to plan, debug, test and optimize our chips before anything is committed to silicon

*** Component Specification and Implementation

**** Nand

The starting point of our computer architecture is the /Nand/ gate which realizes the following Boolean function:

| a | b | Nand(a,b) |
|---+---+-----------|
| 0 | 0 |         1 |
| 0 | 1 |         1 |
| 1 | 0 |         1 |
| 1 | 1 |         0 |

We can also use API style notation to describe the same function:

#+begin_src

Chip name: Nand
Input: a, b
Output: out
Function: if ((a==1) and (b==1)) then out = 0, else out = 1

#+end_src

The API description is more concise and it specifies the chip's name, its inputs and outputs and the function that it performs. It will be used in the rest of this documentation.

**** Not

Also called an /inverter/. It realizes the following API:

#+begin_src

Chip name: Not
Input: in
Output: out
Function: if (in==0) then out=1, else out=0

#+end_src

Given the rules of Boolean algebra: =~ a = ~ (a ^ t) => Nand(a, True)=

**** And

Realizes the following API:

#+begin_src

Chip name: And
Input: a, b
Output: out
Function: if ((a==1) and (b==1)) then out=1, else out=0

#+end_src

=a ^ b = ~ (~ ( a ^ b )) => Not(Nand(a, b))=

**** Or

The /Or/ gate realizes the following function:

#+begin_src

Chip name: Or
Input: a, b
Output: out
Function: if ((a==1) or (b==1)) then out=1, else out=0

#+end_src

According to De Morgan's Laws =a ∨ b = ~ ( ~ a ∧ ~ b)= which can be represented as =Not(And(Not(a), Not(b)))=.

**** Xor

The /Xor/ gate realizes the following function:

#+begin_src

Chip name: Xor
Input: a, b
Output: out
Function: if (a != b) then out=1, else out=0

#+end_src

Xor can be represented in Boolean notation as: =(a V b) ^ ~ (a ^ b)= which can be represented as =And(Or(a,b), Not(And(a,b)))=

**** Multiplexer

A /multiplexer/ is a three-input gate. Two input bits /a/ and /b/ are interpreted as /data bits/ and a third input bit named /sel/ is a interpreted as a /selection bit/. It routes one of the /data bits/ to the /output/ based on the /selection bit/.

Here is the API:

#+begin_src

Chip name: Mux
Input: a, b, sel
Output: out
Function: if (sel==0) then out=a, else out=b

#+end_src

This logic can be noted as: =(~ sel ^ a) V (sel ^ b)=

**** Demultiplexer

It performs the opposite function of the /multiplexer/. It takes a single input and routes it to one of two possible outputs. It has this API:

#+begin_src

Chip name: DMux
Input: in, sel
Output: a, b
Function: if (sel==0) then {a,b} = {in,0}, else {a,b} = {0,in}

#+end_src

We can see that /a/ will only be true if /sel/ is /false/ and /in/ is /true/, therefore : =a = ~self^in=. /b/ will only be true when /sel/ is /true and /in/ is true, therefore =b = sel^in=.

**** Multi-bit Versions

It's a simple matter of arranging the one-bit gates into n-bit arrays that operate on each bit separately. In this case we implement 16-bit version of the gates.

***** Mistakes and Lessons Learned

My first attempt was to copy the /implementation/ of each gate 16 times, which is unnecessarily complex. It is much more concise to use the gate already implemented directly. This enforced the distinction between =specification= and =implementation= that the book emphasizes. As we move to more complex chips, we can treat the previous chips as /black boxes/ and not worry about the details of how they are implemented.

**** Multi-way variants

Logic gates that operate on one or two inputs can be generalized to gates that operate on multiple inputs.
The way to implement them is to try to express the logic of the multiple inputs a /fork/ of the logic of the gates already implemented. Since the logic is the same, we won't go into details for each chip.

***** Or8Way

/Or8Way/ the following API:

#+begin_src

Chip name: Or8Way
Input: in[8]
Output: out
Function: out = Or(in[0], in[1], ..., in[7])

#+end_src

This can be implemented by using /Or/ for two inputs and then forking the output and using it as input for the next /Or/.

The logic looks like this:

#+begin_src

    Or(a=in[0] , b=in[1] , out=out1);
    Or(a=out1 , b=in[2] , out=out2);
    Or(a=out2 , b=in[3] , out=out3);
  ...

#+end_src

*Note:* The general logic is to express the Multi-way variant using a combination of the two-inputs variant.

***** Multi-way/Multi-bit multiplexer

/Mux4Way16/ has the following API:

#+begin_src

Chip name: Mux4Way16
Input: a[16], b[16], c[16], d[16], sel[2]
Output: out[16]
Function: if (sel==00,01,10,11) then out=(a,b,c,d)

#+end_src

This can be implemented using this : =Mux16(Mux16(a,b),Mux16(c,d))=

/Mux8Way16/ is implemented the same way.

***** Multi-way demultiplexer

/DMux4Way/ has the following API:

#+begin_src

Chip name: DMux4Way
Input: in, sel[2]
Output: a, b, c, d
Function: if (sel==00) then {a,b,c,d} = {in,0,0,0} else
if (sel==01) then {a,b,c,d} = {0,in,0,0} else
if (sel==10) then {a,b,c,d} = {0,0,in,0} else
if (sel==11) then {a,b,c,d} = {0,0,0,in}

#+end_src

To implement this, we first use a /DMux/ with =sel[1]= and then route the output to two other /DMux/ gates.

/DMux8Way/ can be implemented in the same way.

***** Mistakes and Lessons Learned

In programming languages =Array[0]= will be the index of the left-most element of the array. But in /HDL/ =sel[0]= is the *least significant bit* so it's the rightmost bit in the binary representation.
This led me to some confusion and headaches when implementing the /DMux/ multi-way variants.

** Chapter 2: Boolean Arithmetic
*** Introduction and Roadmap

Every general-purpose computer is required to perform arithmetic operations on signed integers. We'll start by developing logic gates that carry on /addition/ and /sign conversion/. The subsequent operations can be built using these two. In this chapter we will build:

- Half-adder: designed to add two bits
- Full-adder: designed to add three bits
- Adder: designed to add two n-bit numbers
- Incrementer: adds 1 to a given number
- The Arithmetic Logic Unit (ALU): Computes a set of arithmetic operations

*** Core Concepts

- Inside computers, everything is represented using binary code
- A pair of binary numbers can be added bitwise from right to left, while keeping track of the carry bit
- Signed binary numbers can represented using the /two's complement/ method.

  *Note:* For more information about the /two's complement/ method check: Susanna Epp's *Discrete Mathematics with Applications* (5th Ed) - Section 2.5 : /Application: Number Systems and Circuits for Addition/

*** Component Specification and Implementation

**** Half-adder

The half-adder computes the sum of two 1-bit inputs, producing a *sum* and a *carry*. It has the following API snf truth table:

#+begin_src

Chip name: HalfAdder
Input: a, b
Output: sum, carry
Function: sum = LSB of a + b, carry = MSB of a + b

#+end_src

| a | b | sum | carry |
|---|---|-----|-------|
| 0 | 0 |  0  |   0   |
| 0 | 1 |  1  |   0   |
| 1 | 0 |  1  |   0   |
| 1 | 1 |  0  |   1   |

From the truth table we can see that the sum is logically equivalent to a /Xor/ gate, and the carry is logically equivalent to an /And/ gate.

**** Full-adder

The /full-adder/ computes the sum of three 1-bit inputs, producing a sum and a carry. It has the following truth table:

| a | b | c | sum | carry |
|---|---|---|-----|-------|
| 0 | 0 | 0 |  0  |   0   |
| 0 | 0 | 1 |  1  |   0   |
| 0 | 1 | 0 |  1  |   0   |
| 0 | 1 | 1 |  0  |   1   |
| 1 | 0 | 0 |  1  |   0   |
| 1 | 0 | 1 |  0  |   1   |
| 1 | 1 | 0 |  0  |   1   |
| 1 | 1 | 1 |  1  |   1   |

The /full-adder/ can be implemented with two /half-adders/ and an /Or/ gate.

*Note:* For more information about the method of adding three bits see *Discrete Mathematics with Applications* (5th Ed) - Section 2.5 : /Application: Number Systems and Circuits for Addition/ - Page 97.

**** Adder

Integers are represented using a fixed word size like 8, 16, 32, or 64 bits. The addition of these n-bit numbers is realized using the /adder/ chip. It has the following API:

#+begin_src

Chip name: Add16
Input: a[16], b[16]
Output: out[16]
Function: Adds two 16-bit numbers, the overflow bit is ignored.

#+end_src

The Adder16 proceeds bitwise, from right to left. In step 0 the least significant bits are added and the carry is fed to the next addition. The last overflow carry bit is ignored. This can be implemented with a half-adder for the first addition and full-adders for the rest.

**** Incrementer

An /Incrementer/ is a chip that adds 1 to a given number. It has the following API:

#+begin_src

Chip name: Inc16
Input: in[16]
Output: out[16]
Function: out = in + 1

#+end_src

This can be realized using the previously designed /Add16/ chip. This can be done simply like this:

#+begin_src

CHIP Inc16 {
    IN in[16];
    OUT out[16];

    PARTS:
    Add16(a=in, b[0]=true , b[1..15]=false, out=out);
}

#+end_src

***** Mistakes and Lessons Learned

I first implemented the /Inc16/ chip using 16 /half-adders/, which was overly complex. The lesson is to use an already implemented chip whenever possible and treat it as a black-box abstraction for implementing future chips.

**** The Arithmetic Logic Unit

Using the generic chips built until now, we now turn to constructing the /ALU/. This chip's design is specific to our /Nand to Tetris/ computer. The /ALU/ will be the centerpiece of the /CPU/ chip we'll construct in a later chapter. It has the following API:

#+begin_src

Chip name: ALU
Input: x[16], y[16],  // 16-bit inputs
       zx,             // zero the x input
       nx,             // negate the x input
       zy,             // zero the y input
       ny,             // negate the y input
       f,              // if f==1 then out=x+y else out=x&y
       no              // negate the output
Output: out[16],       // 16-bit output
        zr,            // out == 0
        ng             // out < 0
Function:
  if zx then x = 0      // zero the x input
  if nx then x = !x     // negate the x input
  if zy then y = 0      // zero the y input
  if ny then y = !y     // negate the y input
  if f==1 then out = x + y // integer addition
         else out = x & y  // bitwise and
  if no then out = !out // negate the output
  zr = (out == 0)       // set if output is zero
  ng = (out < 0)        // set if output is negative

#+end_src

Given two 16-bit inputs /x/ and /y/ and six /control bits/, the /ALU/ computes a set of eighteen arithmetic and logical operations as seen in the tables below:

**ALU Control Bits:**

| Control bit | Function                              |
|-------------+---------------------------------------|
| zx          | Zero the x input                      |
| nx          | Negate the x input                    |
| zy          | Zero the y input                      |
| ny          | Negate the y input                    |
| f           | Function select: 1 for add, 0 for AND |
| no          | Negate the output                     |

**ALU Operations:**

| zx | nx | zy | ny | f | no | out |
|----+----+----+----+---+----+-----|
|  1 |  0 |  1 |  0 | 1 |  0 | 0   |
|  1 |  1 |  1 |  1 | 1 |  1 | 1   |
|  1 |  1 |  1 |  0 | 1 |  0 | -1  |
|  0 |  0 |  1 |  1 | 0 |  0 | x   |
|  1 |  1 |  0 |  0 | 0 |  0 | y   |
|  0 |  0 |  1 |  1 | 0 |  1 | !x  |
|  1 |  1 |  0 |  0 | 0 |  1 | !y  |
|  0 |  0 |  1 |  1 | 1 |  1 | -x  |
|  1 |  1 |  0 |  0 | 1 |  1 | -y  |
|  0 |  1 |  1 |  1 | 1 |  1 | x+1 |
|  1 |  1 |  0 |  1 | 1 |  1 | y+1 |
|  0 |  0 |  1 |  1 | 1 |  0 | x-1 |
|  1 |  1 |  0 |  0 | 1 |  0 | y-1 |
|  0 |  0 |  0 |  0 | 1 |  0 | x+y |
|  0 |  1 |  0 |  0 | 1 |  1 | x-y |
|  0 |  0 |  0 |  1 | 1 |  1 | y-x |
|  0 |  0 |  0 |  0 | 0 |  0 | x&y |
|  0 |  1 |  0 |  1 | 0 |  1 | x\vert{}y |

The operations are performed in order. For example if we want to compute the binary operation /27 - 1/ we proceed as follows:

- We feed the 16-bit binary code for 27 to the x input
- We set the /control bits/ to =001110=

let's walk through the operations to demonstrate that /x - 1/ is indeed computed:

- =zx = 0= and =nx = 0= => do nothing to /x/
- =zy = 1= => zero the /y/ input (y = 0)
- =ny = 1= => negate the /y/ input (y = -1)
- =f = 1= => perform x + y
- =no = 0= => don't negate the output

So at the end this ends up computing x + (-1).

*Implementation:*

We use /Mux16/ and /Not16/ for zeroing and negating outputs. In case of /x/ we have:

#+begin_src

    Mux16(a=x , b=false , sel=zx , out=xZeroed );
    Not16(in=xZeroed , out=xNegated );
    Mux16(a=xZeroed , b=xNegated , sel=nx , out=xResult );

#+end_src

We use /Add16/ and /And16/ to compute f and /Mux16/ for selection and then we use /Not16/ to postprocess the output.

#+begin_src

    Add16(a =xResult , b =yResult , out =addXY );
    And16(a=xResult , b=yResult , out=andXY );
    Mux16(a=andXY , b=addXY , sel=f , out=preOut );

    // postprocess output
    Not16(in=preOut , out=invertedOut );

#+end_src

All that's left now is outputting /ng/ and /zr/ bits. /ng/ is the /MSB/ of the whole output, and /zr/ can be calculated using a multi-way /Or/ gate. Since we only have an /Or8Way/ gate, we split the 16-bit output into two 8-bit parts, and use /Or8Way/ on each part.

#+begin_src

    Mux16(a=preOut , b=invertedOut , sel=no ,out=out, out[15] = ng, out[0..7]=lowerout, out[8..15]=upperout);

    // compute zr
    Or8Way(in=lowerout , out=lowerOr );
    Or8Way(in=upperout , out=upperOr );
    Or(a=lowerOr , b=upperOr , out=fullOr );
    Not(in=fullOr , out=zr );

#+end_src

** Chapter 3: Memory

*** Introduction and Roadmap
Every computer system needs to /store values over time/. The gates we implemented in previous chapters do not account for time and are referred to as =combinational chips=. In this chapter we will build a series of memory devices. These chips have the notion of a =clock cycle= and are referred to as =sequential chips=. They depend not only on the combination of their /inputs/ at a given time, but also on the /inputs/ and /outputs/ processed /previously/.

We will build:
- *Bit:* A single bit register
- *Register:* A 16-bit register chip
- *RAM:* A series of RAM devices with increasing number of registers
- *Counter:* A memory device that increments its value in every time unit


*** Core Concepts


- In /sequential logic/ we need access to the /current/ inputs and the /previous/ inputs and outputs
- This notion of /current/ and /previous/ imply a notion of time and the question of how to model it
- Time is modeled using a /clock/ that generates an ongoing train of binary signals referred to as /tick/ and /tock/
- The time between the beginning of a /tick/ and the end of a /tock/ is called a /cycle/
- Our model of time will be discrete. We ignore continuous change and care about the state of the world only during successive cycles
- The discrete model of time helps in ignoring the randomness of communication and synchronizing the operation of multiple chips.
- These cycles are achieved with the help of the *clock* and lower level Data-flip flop (DFF) chip.
- The duration of the clock cycle should be slightly longer than the most time consuming operation.
- The clock signal, realized using a binary signal, is broadcasted to every memory chip.

*** Component Specification and Implementation

**** Data Flip-Flop (DFF)

The /DFF/ is the most elementary sequential chip. It implements the simple time dependent behavior: =out(t) = in(t-1)=

This time dependency is realized by feeding the /master clock/ input directly to all /DFF/ gates. These gates will emit the input fed to them at the next clock cycle. In /Nand to Tetris/ we treat the /DFFs/ as elementary builtin low-level parts embedded deep within other memory devices.

**** Bit

/Bit/ is a single-bit register with the following API:

#+begin_src

Chip name: Bit
Input: in, load
Output: out
Function: If load(t) then out(t+1)=in(t) else out(t+1)=out(t)

#+end_src

The chip can store a single bit of information - 0 or 1 - over time. The /load/ input enables the register for writes. As long as the /load/ bit is not asserted the register is /latched/, maintaining its current state.

This behavior can be implemented using a /DFF/ and a /Multiplexer/. The /load/ bit is fed directly to the /sel/ bit of the /Mux/. The output of the /DFF/ and the current input are fed directly to the /Mux/.

#+begin_src
    Mux(a=currentVal, b=in, sel=load, out=muxOut );
    DFF(in=muxOut, out=currentVal, out=out );
#+end_src

**** Register

The /Register/ chip stores a 16-bit value and updates it based on the /load/ bit. It has the following API:

#+begin_src

Chip name: Register (16-bit register)
Input: in[16], load
Output: out[16]
Function:
  if load(t) then out(t+1) = in(t)
  else out(t+1) = out(t)

#+end_src

This chip can be implemented as an array of 16 /Bit/ chips:

#+begin_src

    Bit(in=in[0], load=load, out=out[0]);
    Bit(in=in[1], load=load, out=out[1]);
    Bit(in=in[2], load=load, out=out[2]);
  ...

#+end_src

**** RAM

A direct-access memory unit, also called /Random Access Memory/ is an aggregate of n /register/ chips. Each register can be selected and made available for read/write operations using an address between =0= and =n - 1=. This access time is /instantaneous/ and independent of the size of the /RAM/. Here is the API:

#+begin_src

Chip name: RAMn
Input: in[16], load, address[k] (k = log₂n)
Output: out[16]
Function:
Out emits the value stored at the memory location (register) specified by address.
If load==1, then the memory location specified by address is set to the value of in.
The loaded value will be emitted by out from the next time step onward.

#+end_src

***** RAM8

As the name suggests, /RAM8/ is an aggregate of 8 /register/ chips. What we need to implement is the logic of selecting between these chips. This can be boiled down to two steps:

1. Direct the /load/ bit to the register specified by *address*.
   This can be achieved using the already implemented /Dmux8Way/
2. Direct the output of the register selected to the output of the RAM8
   This can be achieved using the already implemented /Mux8Way16/


***** RAM64

/RAM64/ can be implemented as an aggregate of 8 /RAM8/ chips. The selection logic is basically the same. This time we split the /address/ into two:

- =address[3..5]= is used for the selection logic between the 8 /RAM8/ chips:

  #+begin_src

    DMux8Way(in=load, sel=address[3..5], a=load1, b=load2, c=load3, d=load4, e=load5, f=load6, g=load7, h=load8);

    .... // RAM8 chips

    Mux8Way16(a=r1, b=r2, c=r3, d=r4, e=r5, f=r6, g=r7, h=r8, sel=address[3..5], out=out);

  #+end_src

- =address[0..2]= is used for the selection logic inside the selected /RAM8/ chip:

  #+begin_src

    ...

    RAM8(in=in, load=load1, address=address[0..2], out=r1);
    RAM8(in=in, load=load2, address=address[0..2], out=r2);

    ...

  #+end_src


/RAM512/ and /RAM4k/ can be implemented using the same logic. This symmetry makes the design simple and beautiful.

***** RAM16K

/RAM16k/ can be implemented using 4 /RAM4k/ chips. This time we use a /Dmux4Way/ and /Mux4Way/ for selection:

#+begin_src

    DMux4Way(in=load , sel=address[12..13] , a=load1 , b=load2 , c=load3 , d=load4 );

    RAM4K(in=in,load=load1, address=address[0..11], out=r1);
    RAM4K(in=in, load=load2, address=address[0..11], out=r2);
    RAM4K(in=in, load=load3, address=address[0..11], out=r3);
    RAM4K(in=in, load=load4, address=address[0..11], out=r4);

    Mux4Way16(a=r1 , b=r2 , c=r3 , d=r4 , sel=address[12..13] , out=out);

#+end_src

**** Counter

The /program counter/ or /PC/ is a chip that knows how to increment its value by 1 each time unit. It has the following API:

#+begin_src

Chip name: PC
Input: in[16], load, inc, reset
Output: out[16]
Function:
  If reset(t) then out(t+1) = 0
  Else if load(t) then out(t+1) = in(t)
  Else if inc(t) then out(t+1) = out(t) + 1
  Else out(t+1) = out(t)

#+end_src


Its interface is similar to the /register/ chip but it also has /inc/ and /reset/ control bits. When =inc == 1= the /counter/ increments its value every clock cycle. If we want to reset the counter we set the /reset/ bit. Setting the /load/ bit allows us to set the /PC/ to the value of /in/. The key behavior to keep in mind is the /order of priority/ of the control bits, which is =reset > load > inc=.

To implement this we use three /Mux16/ chips that handle the selection priority logic with an /Inc16/ chip:

#+begin_src

    Inc16(in=regOut , out=incOut);

    Mux16(a=regOut , b=incOut , sel=inc , out=incOrHold );
    Mux16(a=incOrHold , b=in , sel=load , out=loadOrInc );
    Mux16(a=loadOrInc , b=false , sel=reset , out=nextPC);

#+end_src

The /register/ can be made to always load the /nextPC/ since the logic is already taken care of. The output is then fed back to the first /Mux16/:

#+begin_src

    Register(in=nextPC , load=true , out=regOut, out=out);

#+end_src

** Chapter 4: Machine Language

*** Introduction and Roadmap

Before we complete our /hardware platform/ we have to understand its purpose and its function. This chapter is devoted to the study of the *machine language* that our platform seeks to realize. This entails a detailed study of the /Hack/ language specification and how it relates to hardware, so the specification section is more expansive than in previous sections. At the end we will write two programs in /Hack assembly/:

- *Mult.asm:* A program that computes the value of /R0/ and /R1/ and stores the value in /R2/
- *Fill.asm:* A program that blackens the screen when the keyboard is pressed.

*** Core Concepts and Hack Specification

A machine language can be viewed as an agreed-upon formalism designed to manipulate a /memory/ using a /processor/ and a set of /registers/. Unlike high-level languages, machine language is tightly related to the low-level details of the target hardware.

**** The Hack Machine Language

/Hack/ is a 16-bit computer that follows the paradigm known as /Von Neumann/ architecture. Before introducing the /Hack/ language specification, let's begin with a conceptual description of the /Hack/ computer:

***** Memory

The /Hack/ platform uses two memory units: a /data memory/ and an /instruction memory/. The /data memory/ stores binary values that the computer manipulates. The /instruction memory/ stores program instructions. They are both 16-bit wide.

The /data memory/ (RAM) is a read/write device. /Hack/ instructions can read data from and write data to selected /RAM/ registers. The selected RAM register is referred to as /M/. For example the instruction =M = 0= sets the selected RAM register to =0=.

The /instruction memory/ (ROM) is a read-only device. There's always a value in the /address/ input of the instruction memory. We refer to it as the /current instruction/.

***** Registers

/Hack/ instructions are designed to manipulate three 16-bit registers:

- /Data register (D):/ Its role is to store a 16-bit value
- /Address register (A):/ It serves as both an address register and a data register
- /Selected Memory register (M):/ Serves as an address register.

***** Addressing

The /Hack/ instruction =@xxx= sets the /A/ register to the value =xxx=. This has two sides effects:

- It makes the RAM register whose address is =xxx= the selected memory register /M/
- It makes the value of the /ROM/ register whose address is =xxx= the *selected instruction*

=@xxx= sets the stage for two different scenarios: Manipulating the data of the selected register or doing something with the selected instruction. Let's look at an example:

#+begin_src

 // This sets the value of RAM[100] to 17

  @17
  D=A
  @100
  M=D

#+end_src

In the first pair of instructions, A functions as a /data/ register and in the second it serves as a /memory/ register.

***** Branching

By default the /Hack/ computer executes one instruction after another, but we can use a /jump instruction/ to select the instruction we want to execute next. For example to execute the instruction number 29 we do the following:

#+begin_src

  @29
  0;JMP

#+end_src

Note that jumping can also be conditional. We'll introduce this in the specification.

***** Variables

The =xxx= in the /Hack/ instruction =@xxx= can either be a constant or a symbol. If the instruction is =@x= where =x= is a symbol bound to, say, =513=. Then the /A/ register is set to =513=. This gives the /Hack/ assembly language the ability to store variables:

#+begin_src

  // This code performs x=17
  @17
  D=A
  @x
  M=D

#+end_src

The /Hack/ language features built-in symbols that will be introduced later.

***** Program example

Before we introduce the full specification of the /Hack/ language. Let's just get a taste of the full syntax. This program computes the sum =1+2+3+...+N= where /N/ is stored in /RAM[0]/. The output is then stored in /RAM[1]/

#+begin_src
// File: Sum1toN.asm
// Computes RAM[1]=1+2+3+...+RAM[0]
// Usage: put a value>=1 in RAM[0]
    // i = 1
    @i
    M=1
    // sum = 0
    @sum
    M=0

(LOOP)
    // if (i > R0) goto STOP
    @i
    D=M
    @R0
    D=D-M
    @STOP
    D;JGT
    // sum = sum + i
    @sum
    D=M
    @i
    D=D+M
    @sum
    M=D
    // i = i + 1
    @i
    M=M+1
    // goto LOOP
    @LOOP
    0;JMP

(STOP)
    // R1 = sum
    @sum
    D=M
    @R1
    M=D

(END)
    @END
    0;JMP

#+end_src

***** The Hack Language Specification

The /Hack/ machine language consists of two instruction types as shown in this table:

*A-instruction:*

Symbolic: @xxx (xxx is a decimal value ranging from 0 to 32767, or a symbol bound to such a decimal value)

Binary: 0vvv vvvv vvvv vvvv

*C-instruction:*

Symbolic: dest = comp ; jump

Binary: 111a cccccc ddd jjj

*comp bits:*

| comp (a=0) | comp (a=1) | c1 | c2 | c3 | c4 | c5 | c6 |
|------------|------------|----|----|----|----|----|----|
| 0          | 0          | 1  | 0  | 1  | 0  | 1  | 0  |
| 1          | 1          | 1  | 1  | 1  | 1  | 1  | 1  |
| -1         | -1         | 1  | 1  | 1  | 0  | 1  | 0  |
| D          | D          | 0  | 0  | 1  | 1  | 0  | 0  |
| A          | M          | 1  | 1  | 0  | 0  | 0  | 0  |
| !D         | !D         | 0  | 0  | 1  | 1  | 0  | 1  |
| !A         | !M         | 1  | 1  | 0  | 0  | 0  | 1  |
| -D         | -D         | 0  | 0  | 1  | 1  | 1  | 1  |
| -A         | -M         | 1  | 1  | 0  | 0  | 1  | 1  |
| D+1        | D+1        | 0  | 1  | 1  | 1  | 1  | 1  |
| A+1        | M+1        | 1  | 1  | 0  | 1  | 1  | 1  |
| D-1        | D-1        | 0  | 0  | 1  | 1  | 1  | 0  |
| A-1        | M-1        | 1  | 1  | 0  | 0  | 1  | 0  |
| D+A        | D+M        | 0  | 0  | 0  | 0  | 1  | 0  |
| D-A        | D-M        | 0  | 1  | 0  | 0  | 1  | 1  |
| A-D        | M-D        | 0  | 0  | 0  | 1  | 1  | 1  |
| D&A        | D&M        | 0  | 0  | 0  | 0  | 0  | 0  |
| D\vert{}A  | D\vert{}M  | 0  | 1  | 0  | 1  | 0  | 1  |

*dest bits:*

| dest | d1 | d2 | d3 | effect                  |
|------+----+----+----+-------------------------|
| null |  0 |  0 |  0 | The value is not stored |
| M    |  0 |  0 |  1 | RAM[A]                  |
| D    |  0 |  1 |  0 | D reg                   |
| MD   |  0 |  1 |  1 | RAM[A], D reg           |
| A    |  1 |  0 |  0 | A reg                   |
| AM   |  1 |  0 |  1 | A reg, RAM[A]           |
| AD   |  1 |  1 |  0 | A reg, D register       |
| AMD  |  1 |  1 |  1 | A reg, RAM[A], D reg    |

*jump bits:*

| jump | j1 | j2 | j3 | effect             |
|------+----+----+----+--------------------|
| null |  0 |  0 |  0 | No jump            |
| JGT  |  0 |  0 |  1 | If comp > 0 jump   |
| JEQ  |  0 |  1 |  0 | If comp = 0 jump   |
| JGE  |  0 |  1 |  1 | If comp ≥ 0 jump   |
| JLT  |  1 |  0 |  0 | If comp < 0 jump   |
| JNE  |  1 |  0 |  1 | If comp ≠ 0 jump   |
| JLE  |  1 |  1 |  0 | If comp ≤ 0 jump   |
| JMP  |  1 |  1 |  1 | Unconditional Jump |

****** A-instruction

The A-instructions starts with an op-code of =0= and sets register A to a 15-bit value. This sets the stage for a subsequent instruction where /register A/ can function either as a data registers (loading a constant), a memory register (manipulating M). It can also set the stage for a /jump destination/.

****** C-instruction

The C-instruction answers three questions:
- What to compute, which is an /ALU/ operation denoted /comp/
- Where to store the computed value denoted as /dest/
- What to do next, specified by /jump/


******* Computation Specification (comp)

As we've seen before, the /Hack ALU/ is designed to compute the output of a fixed set of functions on two 16-bit inputs. In the /Hack computer/ we will realize, the first /ALU/ input feeds from the /D/ register and the second feeds either from the /A/ or /M/ register (determined by the /a bit/). The computed function is thus specified by 7-bits: the /a bit/ and the six /c/ bits. The relevant functions are documented in the table above.

To illustrate, suppose we want to compute =D-1= (we don't care for now about the /dest/ and /jump/). This will be achieved by : 111_0001110_000000.

******* Destination Specification (dest)

The /ALU/ output can be stored in zero, one, two, or three possible destinations.

Suppose we want to increment the value of the memory register whose address is 7. This can be achieved with:

#+begin_src

0000000000000111    // @7
1111110111011000    // DM = M + 1

#+end_src

******* Jump Directive (jump)

The jump field of the C-instruction specifies what to do next. The default is to fetch and execute the next instruction. There are eight possible jump conditions as seen in the table above.

******* Symbols

There's a list of predefined symbols in the /Hack/ language:

#+caption: Predefined Hack Symbols
| Symbol | Address Range |
|--------+---------------+
| SP     |             0 |
| LCL    |             1 |
| ARG    |             2 |
| THIS   |             3 |
| THAT   |             4 |
| R0–R15 |          0–15 |
| SCREEN |         16384 |
| KBD    |         24576 |

Of note are the /input / output/ SCREEN and KBD symbols. Our /Hack/ computer can be connected to a screen and a keyboard. Both these devices interact with the computer platform through /memory maps/.

Drawing pixels on the screen is done by writing binary values to the memory segment associated with the screen. The screen's content is represented by a /memory map/ stored in an /8k/ block of 16-bit words. Each row is represented by thirty-two consecutive 16-bit words. We can either read the content of the screen or manipulate the bits and write them back to the relevant memory section.

Listening to the keyboard is done through reading the memory section associated with the keyboard. When a key is pressed on the keyboard, its 16-bit character code appears at /RAM[KBD]/


*** Project

**** Mult.asm:

The input of the program are the values stored in R0 and R1. The program computes R0 * R1 and stores and value in R2.
A way to achieve this is to initialize R2 to =0= and then perform =R0 + R2= /R1/ times. In this case /R1/ serves as the /count/ and we can simply decrement it each time we loop.


***** Mistakes and lessons learned

At first I declared a variable /n/ to serve as the count and used /prod/ to keep track of the product. These are unnecessary and we can just use the R registers themselves, which greatly simplifies the logic. While declaring variables seems to be the natural choice is high-level languages, writing assembly does require a shift in how we think about the logic of a program.

#+caption: No need to declare new variables
#+begin_src

@n
M=0
@prod
M=0

#+end_src
