#+title: Project 6: The Assembler

* Structure and planning

- *main.rs:* Instantiates the Assembler, runs it and handles top level errors.
- *assembler.rs:* Drives the assembly process using the =Parser= and =Code= modules.
- *Parser.rs:* Reads the input file and offers a convenient way to skip through the comments and bank lines, breaking instructions into their main components.
- *instruction.rs:* Keeps track of the current instruction and the parsing Regex.
- *Code.rs:* Translates symbolic Hack mnemonics into their binary codes.

* Assembler.rs

The assembler crate defines the =Assembler= struct with the following fields:

- parser: Contains an instance of the Parser.

It also defines these methods:

** build

Creating an instance of the =Assembler= involves reading an env variable for the source file, and checking if the file exists.
This operation can fail for a variety of reasons (For example file not existing or wrong extension), so the method returns a =Result= with a =Box<dyn Error>= variant. The error is propagated and handled in =main.rs= where we exist the program when an Error variant is encountered. There's no reason to continue if we can't successfully create an instance of the Assembler.

* Parser.rs

The assembler crate defines the =Parser= struct with the following fields:

- contents: A vec of Strings that contains the contents of the source file.
- file_index: Keeps track of our position in the file.
- current_line: Keeps track of instruction lines. For now it just skips comments and empty lines. 
- instruction: Holds an instance of the Instruction type, This type will later hold other fields related to instructions.
 
The Parser also defines these methods:

** build

Returns an instance of the =Parser=. Note that using a functional style with closures is much more efficient.
We are returning a =Result= for the same reasons the =Assembler= returns a =Result=.

#+begin_src rust
  
  let contents: Vec<_> = contents
      .lines()
      .map(|s| s.trim().to_string())
      .collect();

#+end_src

** has_more_lines

Returns true if there are more lines in the file. Initially it should return =false=.

** advance

If has_more_lines is false then we have nothing more to do, we return an Error. Otherwise, we increment our position in the file and if it's a valid instruction (for now it's just any line that is not empty and is not a comment) we increment =current_line= and update =instruction.current=.


** instruction_type

Returns the type of the current valid instruction. I opted for using =and_then= on the =current_instruction= option. This makes it much easier than having to check for a Some variant of =current_instruction= for each if statement. Note that we have to use =as_ref()= here to avoid moving the string out of the =Option= and into the Closure.

#+begin_src rust

  pub fn instruction_type(&self) -> Option<InstructionType> {
      self.instruction.current.as_ref().and_then(|current| {
  	// The match logic gets here
      })

#+end_src

I am using the =Regex= crate for using Regex to match an instruction to an instruction type. The Regex also contain capture groups that will be used later to extract specific parts of the instruction.

** symbol

If the current instruction is an A instruction of the type @xxx or an L instruction (xxx) we return xxx. This is done by using Regex and capture groups.

We first use =and_then= to extract a reference to the current instruction:

#+begin_src rust
  self.instruction.current.as_ref().and_then(|current_inst| {
      // The extraction logic goes here
  }
  )
#+end_src

Extracting a capture group is done by calling captures on the regular expression and passing the =current_instruction= to it.
Since there are different regular expressions depending if it's an A or L instruction, we first extract the regex:


#+begin_src rust
  // ...

   let regex = match self.instruction_type() {
       Some(InstructionType::AInstruction) => &self.instruction.regex.reg_a,
       Some(InstructionType::LInstruction) => &self.instruction.regex.reg_l,
       _ => return None,
   };

  //..

#+end_src


We can then call captures on =regex= and extract the symbol:

#+begin_src rust

  regex
      .captures(current_inst)
      .and_then(|caps| caps.get(1))
      .map(|m| m.as_str())

#+end_src

* instruction.rs

Defines the =Instruction= struct and the =InstructionType= enum. =Instruction= holds these fields:

- current: holds the current instruction.
- regex: contains an instance of =InstructionRegex= for determining the instruction type and extracting the different mnemonics.

=Instrcution= implements only a simple constructor method:

** new

Constructs an instance of the =Instruction= struct.
